a_practiceproblems.heaps:
Time Complexity:
    buildHeap -> O(n)
    extract -> 0(log n)
    increase -> 0(log n)
    insert   -> 0(log n)

INSERT(S, x) inserts the element x into the set S, which is equivalent to the operation.
MAXIMUM(S) returns the element of S with the largest key. [1st element of the heap]
EXTRACT-MAX(S) removes and returns the element of S with the largest key.
    HEAP-EXTRACT-MAX(A)
    1 if A.heap-size < 1
    2 error “heap underflow”
    3 max =A[1]
    4 A[1]=A[A.heap-size]
    5 A.heap-size = A.heap-size - 1
    6 MAX-HEAPIFY(A,1)
    7 return max

INCREASE-KEY(S, x, k)
    increases the value of element x’s key to the new value k, which is assumed to be at least as large as x’s current key value.
    Max Heap: [Destabilization in predecessors] [All parents must be greater than children]
        Here we need to heapify backwards, from child to parent until parent<child as there are chances that parent might be lesser than child
                      10                                    15   <--
                    /   \                                 /   \
                   7     5 --> Increase to 15   -->      7     10
                  / \   / \                             / \    / \
                 4  3  2   1                           4  3   2   1
    Min Heap : [Destabilization in successors] [All parents must be lesser than children]
        Here we need to heapify from parent to child as there is a chance that parent is greater than child
                      1                                     1
                    /   \                                 /   \
                   5     10 --> Increase to 50   -->     5     40
                  / \   / \                             / \    / \
                 12  30 20 40                          12 30  20  50  <----



DECREASE KEY :
    MaxHeap : [Destabilization in successors]
        Here we need to heapify from parent to child  there is a chance that parent is greater than child.
                      10                                    15
                    /   \                                 /   \
                   7     5 --> Decrease to 0   -->       7     1
                  / \   / \                             / \    / \
                 4  3  2   1                           4  3   2   0 <---



    Min Heap : [Destabilization in predecessors]
          Here we need to heapify backwards, from child to parent until parent<child as there are chances that parent might be lesser than child
                      1                                     0    <---
                    /   \                                 /   \
                   5     10 --> Decrease to 0   -->     5      1
                  / \   / \                             / \    / \
                 12  30 20 40                          12 30  20  40
