Any local variable, formal parameter, or exception parameter used but not declared in a lambda expression
must either be declared final or be effectively final (§4.12.4), or a compile-time error occurs where the use is attempted.

To overcome this, we can come up with 3 potential solutions:

1. Making the variable static.
2. Use Array
3. Atomic Integer

------------------------------------------------------------------------------------------------------------
>Scope of a Lambda Expression
    Point 1.    The body of a lambda expression has the same scope as a nested block.
                The same rules for name conflicts and shadowing apply.
                It is illegal to declare a parameter or a local variable in the lambda that has the same name as a local variable
                int first = 0;
                Comparator<String> comp = (first, second) -> first.length() - second.length();
                    // Error: Variable first already defined
    Point 2.    As another consequence of the “same scope” rule, the this keyword in a lambda expression denotes the this parameter
                of the method that creates the lambda.
                For example, consider

                public class Test123 {
                    @Override
                    public String toString() {
                        return "test1243";
                    }
                    public void doStuff()
                    {
                        X obj = x ->{
                            System.out.println(this.toString());
                        };
                        obj.m1(10);
                    }
                    public static void main(String[] args) {
                        new Test123().doStuff(); // prints test1243
                    }
                }
--------------------------------------------------------------------------------------------------------------------------
Q) What is lambda expression?
Lambda expression in itself is an anonymous method
 i.e. a method with no name which is used to provide implementation of the method defined by a functional interface.
--------------------------------------------------------------------------------------------------------------------------
Q) Rules for Lambda expression resolution
    To infer that object type from the context -
        The parameter type of the abstract method and the parameter type of the lambda expression must be compatible. For Example, if the abstract method in the functional interface specifies one int parameter, then the lambda should also have one int parameter explicitly defined or implicitly inferred as int by the context.
        Its return type must be compatible with the method's type.
        Lambda expression can throw only those exceptions which are acceptable to the method.
----------------------------------------------------------------------------------------------------------------------------
Q) Explain target typing with an example.
    Let's say there is a functional interface IMyFunc

   interface IMyFunc {
       int getValue(int num);
   }
   And a class LambdaDemo with a lambda expression which implements this functional interface.

   public class LambdaDemo {

       public static void main(String[] args) {
       // lambda expression
           IMyFunc myFactorialFunc = (num) -> {
               int fact = 1;
               for(int i = 1; i <= num; i++){
                   fact = i * fact;
               }
               return fact;
           };
           System.out.println("Factorial of 7 is " + myFactorialFunc.getValue(7));
       }
   }
   Here you can see that the lambda expression is assigned to the variable of type IMyFunc(functional interface). Now when the method myFactorialFunc.getValue(7) is called it will know that the lambda expression is providing the implementation of the method getValue() because -

   The parameter type of the abstract method and the parameter type of the lambda expression are compatible.
   getValue() method's return type is compatible with the return type of the lambda expression.
   So you can see in this example how target type of the lambda expression is inferred from the context.
-----------------------------------------------------------------------------------------------------------------------------------------------
(int x, int y) -> x+y; or (x, y) -> x + y; which one of these is a valid lambda expression?

Both of them are valid lambda expressions if used in a correct context.

With the first one (int x, int y) -> x+y; we know that the parameters must be of type int.

In case of (x, y) -> x + y; if used in a correct context type can be inferred from the context in which the lambda expression is executed.

See more lambda expressions examples